#+TITLE: Notes from Mastering API Architecture

* Preface

After reading this book you will understand:

- The fundamentals of REST APIs and how to best build, version, and test APIs
- The architectural patterns involved in building an API platform
- The differences in managing API traffic at ingress and within service-to-service communication, and how to apply patterns and technologies such as API gateways and service meshes
- Threat modeling and key security considerations for APIs, such as authentication, authorization, and encryption
- How to evolve existing systems toward APIs and different target deployments, such as the cloud

And you will be able to:

- Design, build, and test API-based systems
- Help to implement and drive an organization’s API program from an architectural perspective
- Deploy, release, and configure key components of an API platform
- Deploy gateways and service meshes based on case studies
- Identify vulnerabilities in API architecture and implement measured security mitigations
- Contribute to emerging API trends and the associated communities

* Introduction

The authors consider API to mean the following:
- an api represents an abstraction of the underlying implementation
- it is represented by a specification that introduces types
- it has defined semantics or behavior to effectively model the
  exchange of information
- it enables extension to customers or third parties for business
  integration

** Using Architecture Decision Records

There are 4 key sections in an ADR: status, context, decision, and
consequences

* Part I: Designing, Building, and Testing APIs

This section provides the foundational building blocks for API-driven
architectures.

In Chapter 1 you will learn about REST and Remote Procedure Call
(RPC)–based APIs. We will explore specifications and schemas,
recommended standards, strategies for versioning, and how to choose
the right API for your system.

In Chapter 2 you will learn about testing APIs and how different test
styles are best applied to API-driven architectures.

* Chapter 1. Design, Build, and Specify APIs

** Introduction to REST

REpresentational State Transfer (REST) is a set of architectural
constraitns, most commonly applied using HTTP as the underlying
transport protocol.

To be considered restful, our API must ensure that:
- A producer-to-consumer interaction is modeled where the producer
  models resources the consumer can interact with.
- Requests from producer to consumer are stateless, meaning that the
  producer doesn't cache details of the previous request.
- Requests are cachable, meaning the producer can provide hints to the
  consumer where this is appropriate. In HTTP, this is often provided
  in information contained in the header.
- A uniform interface is conveyed to the consumer.
- It is a layered system, abstracting away the complexity of systems
  sitting behind the REST interface.

** The Richardson Maturity Model

*Level 0 - HTTP/RPC*

Establishes that the API is built using HTTP and has the notion of a
single URI. Taking our preceding example of /attendees and not
applying a verb to specify intent, we would open up an endpoint for
exchange. Essentially this represents an RPC implementation over the
REST protocol.

*Level 1 - Resources*

Establishes the use of resources and starts to bring in the idea of
modeling resources in the context of the URI. In our example, if we
added GET /attendees/1 returning a specific attendee, it would start
to look like a level 1 API. Martin Fowler draws an analogy to the
classic object-oriented world of introducing identity.

*Level 2 - Verbs (Methods)*

Starts to introduce the correct modeling of multiple resource URIs
accessed by different request methods (also known as HTTP verbs) based
on the effect of the resources on the server. An API at level 2 can
make guarantees around GET methods not impacting server state and
presenting multiple operations on the same resource URI. In our
example adding DELETE /attendees/1, PUT /attendees/1 would start to
add the notion of a level 2–compliant API.

*Level 3 - Hypermedia Controls*

This is the epitome of REST design and involves navigable APIs by the
use of HATEOAS (Hypertext As The Engine Of Application State). In our
example, when we call GET /attendees/1, the response would contain the
actions that are possible on the object returned from the server. This
would include the option to be able to update the attendee or delete
the attendee and what the client is required to invoke in order to do
so. In practical terms level 3 is rarely used in modern RESTful HTTP
services, and although the navigation is a benefit in flexible UI
style systems, it doesn’t suit interservice API calls. Using HATEOAS
would be a chatty experience and is often short-circuited by having a
complete specification of possible interactions up front while
programming against the producer.

---

When designing API exchanges, the different levels of Richardson
maturity are important to consider. Moving towards level 2 will enable
you to project an understandable resource model to the consumer, with
approporiate actions against the model.

** Introduction to RPC APIs

A remote procedure call (RPC) involves calling a method in one process
but having it execute code in another process.

gRPC is a modern open source high performance RPC. The gRPC attendee
service starts and exposes a gRPC server on a specified port, allowing
methods to be invoked remotely.

A key difference between RPC and REST is state. REST is by definition
stateless, whereas RPC state depends on the implementation. RPC
integrations in certain situations can also build up state as part of
the exchange, which has the convenience of high performance at the
potential cost of reliability and routing complexities.

** A Brief Mention of GraphQL

- RPC offers access to a series of individual functions provided by a
  producer, but does not usually extend a model or abstraction to the
  consumer.
- REST extends a resource model for a single API provided by the producer
  - the consumer needs to query sequentially to build up state on the
    client side. This is wasteful if the consumer is only interested
    in a subset of the fields on the response.

GraphQL introduces a technology later over existing services,
datastores, and APIs that provides a query language to query across
multiple sources. It uses the GraphQL schema language to specify the
types in individual APIs and how they combine.

GraphQL excels when a consumer requires uniform API access over a wide
range of interconnected services.

** REST API Standards and Structure

Some considerations:
- pagination using nextLink
- filtering collections
- error handling

** Summary

In this chapter we have covered how to design, build, and specify APIs and the different circumstances under which you may choose REST or gRPC. It is important to remember that it is not REST versus gRPC, but rather given the situations, which is the most appropriate choice for modeling the exchange. The key takeaways are:

- The barrier to building REST- and RPC-based APIs is low in most technologies. Carefully considering the design and structure is an important architectural decision.

- When choosing between REST and RPC models, consider the Richardson
  Maturity Model and the degree of coupling between the producer and
  consumer.

- REST is a fairly loose standard. When building APIs, conforming to
  an agreed API standard ensures your APIs are consistent and have the
  expected behavior for your consumers. API standards can also help to
  short-circuit potential design decisions that could lead to an
  incompatible API.

- OpenAPI Specifications are a useful way of sharing API structure and
  automating many coding-related activities. You should actively
  select OpenAPI features and choose what tooling or generation
  features will be applied to projects.

- Versioning is an important topic that adds complexity for the
  producer but is necessary to ease API usage for the consumer. Not
  planning for versioning in APIs exposed to consumers is
  dangerous. Versioning should be an active decision in the product
  feature set and a mechanism to convey versioning to consumers should
  be part of the discussion.

- gRPC performs incredibly well in high-bandwidth exchanges and is an
  ideal option for east–west exchanges. Tooling for gRPC is powerful
  and provides another option when modeling exchanges.

- Modeling multiple specifications starts to become quite tricky,
  especially when generating from one type of specification to
  another. Versioning complicates matters further but is an important
  factor to avoid breaking changes. Teams should think carefully
  before combining RPC representations with RESTful API
  representations, as there are fundamental differences in terms of
  usage and control over the consumer code.

The challenge for an API architecture is to meet the requirements from
a consumer business perspective, to create a great developer
experience around APIs, and to avoid unexpected compatibility
issues.



BUILD: make an example api that hits level 2
BUILD: try out gRPC between 2 services
BUILD: try out graphql

* Chapter 2. Testing APIs

** Test Quadrant


Q1

Unit and component tests for technology. These should verify that
the service that has been created works, and this verification should
be performed using automated testing.

Q2

Tests with the business. These ensure what is being built is
serving a purpose. This is verified with automated testing and can
also include manual testing.

Q3

Testing for the business. This is about ensuring that functional
requirements are met and also includes exploratory testing. When
Figure 2-2 was originally created, this type of testing was
manual; now it is possible to perform automated testing in this
area as well.

Q4

Ensuring that what exists works from a technical standpoint. From
Q1 you know that what has been built works; however, when the
product is being used, is it performing as expected? Examples of
performing correctly from a technical standpoint could include
security enforcement, SLA integrity, and autoscaling.

** Test Pyramid

Unit Tests > integration tests > end to end tests

** Contract Testing

Contract testing has 2 components: a consumer and a producer. A
consumer requests data from an API, and a producer responds to the API
requests.


BUILD: Build an api test with pact in python


 But the real value added of this integration strategy is the fact
 that it fosters conversations and collaboration between
 teams. Whenever you need to introduce a breaking change as a
 provider, you can immediately verify which are the consumers that
 will be affected by the change, and initiate a process that involves
 both teams with the final goal of keeping your platform up, running
 and healthy.


https://docs.pact.io/

A key benefit of contract tests is that once the producer agrees to
implement a contract, this decouples the dependency of building the
consumer and producer.

It is worth looking at tooling that writes contracts for you based on
an OpenAPI specification.

** API Component Testing

Component testing can be used to validate that multiple units work
together and should be used to validate behaviour.


 for APIs you would be looking to validate cases such as:

 Is the correct status code returned when a request is made?

 Does the response contain the correct data?

 Is an incoming payload rejected if a null or empty parameter is
 passed in?

 When I send a request where the accepted content type is XML, will
 the data return the expected format?

 If a request is made by a user who does not have the correct
 entitlements, what will the response be?

 What will happen if an empty dataset is returned? Is this a 404 or
 is it an empty array?

 When creating a resource, does the location header point to the
 new asset created?

** Using Stub Servers: Why and How

If you are using contract tests, the generated stub servers can be
used to verify that the consumer can communicate with the producer.

A generated stub server from a contract is not always available and
other options are required, as in the case of testing with an external
API, such as the Microsoft Graph API, or within your organization when
contracts are not used. The simplest one is to hand roll a stub server
that mimics the requests and responses of the service you interact
with.
