#+TITLE: Notes from Mastering API Architecture

* Preface

After reading this book you will understand:

- The fundamentals of REST APIs and how to best build, version, and test APIs
- The architectural patterns involved in building an API platform
- The differences in managing API traffic at ingress and within service-to-service communication, and how to apply patterns and technologies such as API gateways and service meshes
- Threat modeling and key security considerations for APIs, such as authentication, authorization, and encryption
- How to evolve existing systems toward APIs and different target deployments, such as the cloud

And you will be able to:

- Design, build, and test API-based systems
- Help to implement and drive an organization’s API program from an architectural perspective
- Deploy, release, and configure key components of an API platform
- Deploy gateways and service meshes based on case studies
- Identify vulnerabilities in API architecture and implement measured security mitigations
- Contribute to emerging API trends and the associated communities

* Introduction

The authors consider API to mean the following:
- an api represents an abstraction of the underlying implementation
- it is represented by a specification that introduces types
- it has defined semantics or behavior to effectively model the
  exchange of information
- it enables extension to customers or third parties for business
  integration

** Using Architecture Decision Records

There are 4 key sections in an ADR: status, context, decision, and
consequences

* Part I: Designing, Building, and Testing APIs

This section provides the foundational building blocks for API-driven
architectures.

In Chapter 1 you will learn about REST and Remote Procedure Call
(RPC)–based APIs. We will explore specifications and schemas,
recommended standards, strategies for versioning, and how to choose
the right API for your system.

In Chapter 2 you will learn about testing APIs and how different test
styles are best applied to API-driven architectures.

* Chapter 1. Design, Build, and Specify APIs

** Introduction to REST

REpresentational State Transfer (REST) is a set of architectural
constraitns, most commonly applied using HTTP as the underlying
transport protocol.

To be considered restful, our API must ensure that:
- A producer-to-consumer interaction is modeled where the producer
  models resources the consumer can interact with.
- Requests from producer to consumer are stateless, meaning that the
  producer doesn't cache details of the previous request.
- Requests are cachable, meaning the producer can provide hints to the
  consumer where this is appropriate. In HTTP, this is often provided
  in information contained in the header.
- A uniform interface is conveyed to the consumer.
- It is a layered system, abstracting away the complexity of systems
  sitting behind the REST interface.

** The Richardson Maturity Model

*Level 0 - HTTP/RPC*

Establishes that the API is built using HTTP and has the notion of a
single URI. Taking our preceding example of /attendees and not
applying a verb to specify intent, we would open up an endpoint for
exchange. Essentially this represents an RPC implementation over the
REST protocol.

*Level 1 - Resources*

Establishes the use of resources and starts to bring in the idea of
modeling resources in the context of the URI. In our example, if we
added GET /attendees/1 returning a specific attendee, it would start
to look like a level 1 API. Martin Fowler draws an analogy to the
classic object-oriented world of introducing identity.

*Level 2 - Verbs (Methods)*

Starts to introduce the correct modeling of multiple resource URIs
accessed by different request methods (also known as HTTP verbs) based
on the effect of the resources on the server. An API at level 2 can
make guarantees around GET methods not impacting server state and
presenting multiple operations on the same resource URI. In our
example adding DELETE /attendees/1, PUT /attendees/1 would start to
add the notion of a level 2–compliant API.

*Level 3 - Hypermedia Controls*

This is the epitome of REST design and involves navigable APIs by the
use of HATEOAS (Hypertext As The Engine Of Application State). In our
example, when we call GET /attendees/1, the response would contain the
actions that are possible on the object returned from the server. This
would include the option to be able to update the attendee or delete
the attendee and what the client is required to invoke in order to do
so. In practical terms level 3 is rarely used in modern RESTful HTTP
services, and although the navigation is a benefit in flexible UI
style systems, it doesn’t suit interservice API calls. Using HATEOAS
would be a chatty experience and is often short-circuited by having a
complete specification of possible interactions up front while
programming against the producer.

---

When designing API exchanges, the different levels of Richardson
maturity are important to consider. Moving towards level 2 will enable
you to project an understandable resource model to the consumer, with
approporiate actions against the model.

** Introduction to RPC APIs

A remote procedure call (RPC) involves calling a method in one process
but having it execute code in another process.

gRPC is a modern open source high performance RPC. The gRPC attendee
service starts and exposes a gRPC server on a specified port, allowing
methods to be invoked remotely.

A key difference between RPC and REST is state. REST is by definition
stateless, whereas RPC state depends on the implementation. RPC
integrations in certain situations can also build up state as part of
the exchange, which has the convenience of high performance at the
potential cost of reliability and routing complexities.

** A Brief Mention of GraphQL

- RPC offers access to a series of individual functions provided by a
  producer, but does not usually extend a model or abstraction to the
  consumer.
- REST extends a resource model for a single API provided by the producer
  - the consumer needs to query sequentially to build up state on the
    client side. This is wasteful if the consumer is only interested
    in a subset of the fields on the response.

GraphQL introduces a technology later over existing services,
datastores, and APIs that provides a query language to query across
multiple sources. It uses the GraphQL schema language to specify the
types in individual APIs and how they combine.

GraphQL excels when a consumer requires uniform API access over a wide
range of interconnected services.

** REST API Standards and Structure

Some considerations:
- pagination using nextLink
- filtering collections
- error handling

** Summary

In this chapter we have covered how to design, build, and specify APIs and the different circumstances under which you may choose REST or gRPC. It is important to remember that it is not REST versus gRPC, but rather given the situations, which is the most appropriate choice for modeling the exchange. The key takeaways are:

- The barrier to building REST- and RPC-based APIs is low in most technologies. Carefully considering the design and structure is an important architectural decision.

- When choosing between REST and RPC models, consider the Richardson
  Maturity Model and the degree of coupling between the producer and
  consumer.

- REST is a fairly loose standard. When building APIs, conforming to
  an agreed API standard ensures your APIs are consistent and have the
  expected behavior for your consumers. API standards can also help to
  short-circuit potential design decisions that could lead to an
  incompatible API.

- OpenAPI Specifications are a useful way of sharing API structure and
  automating many coding-related activities. You should actively
  select OpenAPI features and choose what tooling or generation
  features will be applied to projects.

- Versioning is an important topic that adds complexity for the
  producer but is necessary to ease API usage for the consumer. Not
  planning for versioning in APIs exposed to consumers is
  dangerous. Versioning should be an active decision in the product
  feature set and a mechanism to convey versioning to consumers should
  be part of the discussion.

- gRPC performs incredibly well in high-bandwidth exchanges and is an
  ideal option for east–west exchanges. Tooling for gRPC is powerful
  and provides another option when modeling exchanges.

- Modeling multiple specifications starts to become quite tricky,
  especially when generating from one type of specification to
  another. Versioning complicates matters further but is an important
  factor to avoid breaking changes. Teams should think carefully
  before combining RPC representations with RESTful API
  representations, as there are fundamental differences in terms of
  usage and control over the consumer code.

The challenge for an API architecture is to meet the requirements from a consumer business perspective, to create a great developer experience around APIs, and to avoid unexpected compatibility issues. In Chapter 2 you will explore testing, which is essential in ensuring services meet these objectives.
